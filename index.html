<!DOCTYPE html>
<html lang="ja">
   <head>
      <title>緊急地震速報</title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
      <meta http-equiv="Pragma" content="no-cache">
      <meta http-equiv="Expires" content="0">
    <style>
        body {
            font-family: sans-serif;
            font-size: 18px;
        }
         .warn {
           background-color: #ff6964;
           animation: blink 1s linear;
         }
        #EEW, #EARTHQUAKEINFO, #Settings {
            backdrop-filter: blur(5px);
            background-color: white;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        }
        h1 {
            margin-top: 0;
            font-size: 24px;
        }
        .large {
            font-size: 18px;
        }
        .warning-box {
            border: 1px solid #ccc;
            padding: 10px;
            margin-bottom: 10px;
            border-radius: 10px;
        }

        #earthquake-info, #earthquake-list {
            margin-bottom: 20px;
        }
        #save-button {
            display: block;
            margin-top: 10px;
        }
        
        button {
    background-color: #4CAF50;
    color: white;
    padding: 12px 20px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
}

button:hover {
    background-color: #3e8e41;
}
input[type=text] {
    width: 35%;
    padding: 12px 20px;
    margin: 8px 0;
    box-sizing: border-box;
    border: 2px solid #ccc;
    border-radius: 4px;
}

input[type=text]:focus {
    border: 2px solid #4CAF50;
}

         @keyframes blink {
           0% {
             background-color: #F0f0f0;
           }
           100% {
             background-color: #ff6964;
           }
         }
    </style>
</head>
<body>
    <div id="EEW">
        <h1>緊急地震速報</h1>
        <div id="earthquake-info"></div>
    </div>
    <div id="EARTHQUAKEINFO">
        <h2>地震情報</h2>
        <div id="earthquake-list"></div>
    </div>
    <div id="Settings">
        <h2>現在地</h2>
        <label for="user-location">現在地:</label>
        <input type="text" id="user-location">
        <button id="save-button">保存</button><p id="location"></p>
        <label>
  <input type="checkbox" id="notificationCheckbox">
  通知を許可する
</label>
    </div>
      <script>
let lastReportNum = null;
let lastReportTime = null;
const earthquakeWarnings = {};
async function getData(apiEndpoint) {
    try {
        const response = await fetch(apiEndpoint, {
            cache: 'no-store'
        });

        const data = await response.json();
        return data;
    } catch (error) {
        console.error(error);
    }
}

async function main() {
    const apiEndpoint1 = 'https://api.iedred7584.com/eew/json/';
    const apiEndpoint2 = 'https://api.wolfx.jp/jma_eew.json';
    const data1 = await getData(apiEndpoint1);
    const data2 = await getData(apiEndpoint2);

    const currentTime = new Date();

    let latestData;
    if (new Date(data1.AnnouncedTime.String) <= new Date(data2.AnnouncedTime)) {
        latestData = {...data2, isIedred: false};
    } else {
        latestData = {...data1, isIedred: true};
    }

    if (latestData.isIedred) {
        const rkIndex = latestData.OriginalText.indexOf('RK');
        const rk = latestData.OriginalText.slice(rkIndex + 2, rkIndex + 5);
        transformedData = {
            isIedred: true,
            EventID: latestData.EventID,
            Title: latestData.Title.String,
            reportnum: latestData.Serial,
            isfinal: latestData.Type.Code === 9,
            iswarn: latestData.Warn,
            iscancel: latestData.Title.Code === 39,
            istrainning: latestData.Status.Code === 10,
            isplumepicenter: latestData.Hypocenter.isAssumption,
            report_time: latestData.AnnouncedTime.String,
            origin_time: latestData.OriginTime.String,
            hypocenter: latestData.Hypocenter.Name,
            magnitude: latestData.Hypocenter.Magnitude.Float,
            depth: latestData.Hypocenter.Location.Depth.Int,
            maxintensity: latestData.MaxIntensity.String,
            latitude: latestData.Hypocenter.Location.Lat,
            longitude: latestData.Hypocenter.Location.Long,
            Accuracy_epicenter: rk[0],
            Accuracy_depth: rk[1],
            Accuracy_magnitude: rk[2],
            forecast: (latestData.Forecast || []).map(item => ({
                chiiki: item.Intensity.Name,
                shindomax: item.Intensity.From,
                shindolowest: item.Intensity.To,
                isWarn: item.Warn
            }))
        };
    } else {
        const rkIndex = latestData.OriginalText.indexOf('RK');
        const rk = latestData.OriginalText.slice(rkIndex + 2, rkIndex + 5);
        transformedData = {
            isIedred: false,
            EventID: latestData.EventID,
            Title: latestData.Title,
            report_time: latestData.AnnouncedTime,
            origin_time: latestData.OriginTime,
            hypocenter: latestData.Hypocenter,
            reportnum: latestData.Serial,
            latitude: latestData.Latitude,
            longitude: latestData.Longitude,
            magnitude: latestData.Magunitude,
            maxintensity: latestData.MaxIntensity,
            depth: latestData.Depth,
            Accuracy_epicenter: rk[0],
            Accuracy_depth: rk[1],
            Accuracy_magnitude: rk[2],
            iscancel: latestData.isCancel,
            isplumepicenter: latestData.isAssumption,
            istrainning: latestData.isTraining,
            iswarn: latestData.isWarn,
            isfinal: latestData.isFinal,
            forecast: (latestData.WarnArea || []).map(item => ({
                chiiki: item.Chiiki,
                shindomax: item.Shindo1,
                shindolowest: item.Shindo2,
                isWarn: item.Type === '警報'
            }))
        };
    }

    if (transformedData) {
        const eventId = transformedData.EventID;
        const reportTime = new Date(transformedData.report_time);
        if (currentTime - reportTime <= 300000) {
            earthquakeWarnings[eventId] = transformedData;
        } else {
            delete earthquakeWarnings[eventId];
        }
    }

    for (const eventId in earthquakeWarnings) {
        const warning = earthquakeWarnings[eventId];
        const reportTime = new Date(warning.report_time);
        if (warning.iscancel && currentTime - reportTime > 15000) {
            delete earthquakeWarnings[eventId];
        } else if (currentTime - reportTime > 300000) {
            delete earthquakeWarnings[eventId];
        }
    }

const earthquakeInfo = document.getElementById('earthquake-info');
let info = '';
const warnings = Object.values(earthquakeWarnings).sort((a, b) => new Date(b.report_time) - new Date(a.report_time));
if (warnings.length === 0) {
    info += `<p>緊急地震速報は発表されていません。</p>`;
} else {
    for (let i = 0; i < warnings.length; i++) {
        const warning = warnings[i];
        info += `<div class="warning-box" id="EEW[${warning.EventID}]">`;
        if (warnings.length > 1) {
            info += `<p class="large">(${i + 1}/${warnings.length})</p>`;
        }
            console.log(warning)
            if (warning.iscancel) {
                info += `<p>緊急地震速報は取り消されました。</p>`;
                    if (notificationCheckbox.checked && Notification.permission === 'granted') {
                sendNotification(warning)
                }
            } else {
            info += ` <p>${warning.iswarn ? '緊急地震速報(警報)' : '緊急地震速報(予報)'}</p> <p>震源地: ${warning.hypocenter}</p> <p>${warning.isfinal ? ((warning.reportnum) ? `最終第${(warning.reportnum)}報` : '最終報') : ((warning.reportnum) ? `第${(warning.reportnum)}報` : '未定義')}</p> <p>`;
            
            if (warning.maxintensity === "不明") {
    info += `<p>予想最大震度: 未発表または0未満</p>`;
} else {
    info += `<p>予想最大震度: ${warning.maxintensity}</p>`;
}

            const userLocation = getUserLocationFromCookie();
if (userLocation) {
    if (warning.maxintensity) {
        const maxIntensity = warning.maxintensity;
        if ((warning.isIedred && warning.iswarn) || (!warning.isIedred && maxIntensity >= 4)) {
            const userLocationData = warning.forecast.find(area => area.chiiki === userLocation);
            if (userLocationData) {
                info += `<p>現在地(${userLocation})の予想震度: ${userLocationData.shindomax}</p>`;
                warning.expectedIntensity = userLocationData.shindomax;
            } else {
                info += `<p>現在地(${userLocation})の予想震度: 不明</p>`;
                warning.expectedIntensity = '不明';
            }
        } else {
            info += `<p>現在地(${userLocation})の予想震度: 不明</p>`;
            warning.expectedIntensity = '不明';
        }
    } else {
        info += `<p>現在地(${userLocation})の予想震度: 不明</p>`;
        warning.expectedIntensity = '不明';
    }
}

            if (!warning.isplumepicenter) {
                info += ` <p>マグニチュード: ${warning.magnitude}</p> <p>深さ: ${(warning.depth ? (warning.depth + 'km') : warning.depth)}</p> `;
                if (warning.origin_time) {
                    info += ` <p>${warning.origin_time} 発生</p> `;
                } else {
                info += ` <p>${warning.origin_time}頃検知</p> <p>仮定震源要素のため、震源の深さおよびM不明</p> `;
            }
const epicenterAccuracyMap = {
    1: 'P 波／S 波レベル越え、IPF 法（1 点）、または仮定震源要素',
    2: 'IPF 法（2 点）',
    3: 'IPF 法（3 点／4 点）',
    4: 'IPF 法（5 点以上）',
    5: '防災科研システム (4点以以下)',
    6: '防災科研システム（5 点以上）',
    7: 'EPOS（海域〔観測網外〕）',
    8: 'EPOS（内陸〔観測網内〕）'
};

const magnitudeAccuracyMap = {
    1: '未定義',
    2: '防災科研システム',
    3: '全点P相',
    4: 'P相/全相混在',
    5: '全点全相',
    6: 'EPOS',
    7: '未定義',
    8: 'P 波／S 波レベル越え、IPF 法（1 点）、または仮定震源要素'
};

if (warning.Accuracy_epicenter) {
    const epicenterAccuracy = epicenterAccuracyMap[warning.Accuracy_epicenter] || '不明';
    const depthAccuracy = epicenterAccuracyMap[warning.Accuracy_depth] || '不明';
    const magnitudeAccuracy = magnitudeAccuracyMap[warning.Accuracy_magnitude] || '不明';
    info += `<p>精度情報 震源: ${epicenterAccuracy}, 深さ: ${depthAccuracy}, マグニチュード: ${magnitudeAccuracy}</p>`;
}
                }
        
        if (warning.isIedred) {
            info += `API: iedred`;
        } else {
            info += `API: wolfx`;
        }
            if (warning.forecast && warning.forecast.length > 0) {
                info += `<p>地域ごとの予想震度(気象庁発表)</p><p>`;
                for (const area of warning.forecast) {
                    info += `${area.chiiki} ${area.shindomax}`;
                    if (area.isWarn) {
                        info += ` - 警報`;
                    }
                    info += `<br>`;
                }
                info += `</p>`;
            } else {
                info += `<p>地域ごとの予想震度(気象庁発表): 未発表</p>`;
            }
            if (notificationCheckbox.checked && Notification.permission === 'granted') {
            sendNotification(warning)
            }
            }
        }
    }

    earthquakeInfo.innerHTML = info;
    if (warnings.some(warning => warning.iswarn)) {
        document.body.classList.add('warn');
    } else {
        document.body.classList.remove('warn');
    }
}

function sendNotification(warning) {
    console.log(warning)
    if (Notification.permission === 'granted') {
        const currentTime = new Date();
        const userLocation = getUserLocationFromCookie();
        const reportTime = new Date(warning.report_time);
        if (
            (!lastReportTime || currentTime - reportTime < 5 * 60 * 1000) &&
            (!lastReportNum || warning.reportnum !== lastReportNum || warning.iscancel)
        ) {
            let notificationTitle = '';
            if (warning.iscancel) {
                notificationTitle = '先程の緊急地震速報は取り消されました。';
            } else {
                const originTime = new Date(warning.origin_time);
                const timeString = `${originTime.getHours()}時${originTime.getMinutes()}分${originTime.getSeconds()}秒頃`;
                if (warning.isfinal) {
                    notificationTitle = `${warning.Title} 最終第${warning.reportnum}報 \n${timeString} ${warning.hypocenter}で地震、\n予想最大震度は${warning.maxintensity === "不明" ? "未発表または0未満" : warning.maxintensity}`;
                } else {
                    notificationTitle = `${warning.Title} 第${warning.reportnum}報 \n${timeString} ${warning.hypocenter}で地震、\n予想最大震度は${warning.maxintensity === "不明" ? "未発または0未満表" : warning.maxintensity}`;
                }
                if (userLocation) {
                    notificationTitle  += `\n現在地の予想震度は${warning.expectedIntensity}`;
                }
                if (warning.isplumepicenter) {
                    notificationTitle += '、\n仮定震源要素のため、Mおよび、深さ不明と推定されます。';
                } else {
                    notificationTitle += `、\nマグニチュードは${warning.magnitude}、深さは${warning.depth}kmと推定されます。`;
                if (warning.isIedred) {
                    notificationTitle += `、\nAPI: iedred`;
                } else {
                    notificationTitle += `、\nAPI: wolfx`;
                }
                }
            }
            new Notification(notificationTitle);
            lastReportTime = currentTime;
            lastReportNum = warning.reportnum;
        }
    }
}



function getUserLocationFromCookie() {
    const cookieValue = document.cookie
        .split('; ')
        .find(row => row.startsWith('userLocation='))
        ?.split('=')[1];
    return cookieValue ? decodeURIComponent(cookieValue) : null;
}

const locationElement = document.getElementById('location');
const userLocation = getUserLocationFromCookie();
if (userLocation) {
    locationElement.textContent = `現在地は ${userLocation}です`;
} else {
    locationElement.textContent = '現在地は登録されていません。.';
}

document.getElementById('save-button').addEventListener('click', () => {
    const userLocation = document.getElementById('user-location').value;
    const date = new Date();
    date.setFullYear(date.getFullYear() + 1);
    document.cookie = `userLocation=${encodeURIComponent(userLocation)}; expires=${date.toUTCString()}; path=/`;
});

const notificationCheckbox = document.querySelector('#notificationCheckbox');

// チェックボックスの状態をローカルストレージから読み込む
const notificationPermission = localStorage.getItem('notificationPermission');
if (notificationPermission === 'true') {
    notificationCheckbox.checked = true;
} else {
    notificationCheckbox.checked = false;
}

// チェックボックスがチェックされたときに、ローカルストレージに保存する
notificationCheckbox.addEventListener('change', () => {
    localStorage.setItem('notificationPermission', notificationCheckbox.checked);
    // チェックボックスがチェックされたときに、通知の許可を求める
    if (notificationCheckbox.checked && Notification.permission !== 'granted') {
        Notification.requestPermission();
    }
});

async function getEarthquakeInformation() {
  try {
    const response = await fetch('https://dev.narikakun.net/webapi/earthquake/post_data.json', {
      cache: 'no-store'
    });
    const data = await response.json();
    const earthquakeList = document.getElementById('earthquake-list');
    if (data.Head.Title === '震度速報') {
      let intensityObservations = '';
      if (data.Body.Intensity && data.Body.Intensity.Observation && data.Body.Intensity.Observation.Pref) {
        for (const pref of data.Body.Intensity.Observation.Pref) {
          if (pref.Area) {
            for (const area of pref.Area) {
              intensityObservations += `<p>${area.Name}: 震度${area.MaxInt}</p>`;
            }
          }
        }
      }
      earthquakeList.innerHTML = `
        <p>震度速報</p>
        ${intensityObservations}
        <p>情報: ${data.Body.Comments.Observation}</p>
      `;
    } else if (data.Control.Title === '震源に関する情報') {
      let depth = data.Body.Earthquake.Hypocenter.Depth;
      if (depth === '0') {
        depth = 'ごく浅い';
      } else {
        depth += ' km';
      }
      earthquakeList.innerHTML = `
        <p>震源地: ${data.Body.Earthquake.Hypocenter.Name}</p>
        <p>${data.Body.Earthquake.OriginTime.replace(/-/g, '/')} 頃発生</p>
        <p>マグニチュード: ${data.Body.Earthquake.Magnitude}</p>
        <p>深さ: ${depth}</p>
        <p>情報: ${data.Body.Comments.Observation}</p>
      `;
    } else if (data.Head.Title === '遠地地震に関する情報') {
      earthquakeList.innerHTML = `
        <p>遠地地震に関する情報</p>
        <p>震源地: ${data.Body.Earthquake.Hypocenter.Name}</p>
        <p>${data.Body.Earthquake.OriginTime.replace(/-/g, '/')} 頃発生</p>
        <p>マグニチュード: ${data.Body.Earthquake.Magnitude}</p>
        <p>情報: ${data.Body.Comments.Observation}</p>
      `;
    } else if (data.Body) {
      let maxIntensity = '';
      if (data.Body.Intensity && data.Body.Intensity.Observation && data.Body.Intensity.Observation.MaxInt) {
        maxIntensity = `<p>最大震度: ${data.Body.Intensity.Observation.MaxInt}</p>`;
      }
      let depth = data.Body.Earthquake.Hypocenter.Depth;
      if (depth === '0') {
        depth = 'ごく浅い';
      } else {
        depth += ' km';
      }
      earthquakeList.innerHTML = `
        <p>震源地: ${data.Body.Earthquake.Hypocenter.Name}</p>
        <p>${data.Body.Earthquake.OriginTime.replace(/-/g, '/')} 頃発生</p>
        <p>マグニチュード: ${data.Body.Earthquake.Magnitude}</p>
        ${maxIntensity}
        <p>深さ: ${depth}</p>
        <p>情報: ${data.Body.Comments.Observation}</p>
      `;
    } else {
      earthquakeList.innerHTML = `<p>地震情報はありません。</p>`;
    }
  } catch (error) {
    console.error(error);
    const earthquakeList = document.getElementById('earthquake-list');
    earthquakeList.innerHTML = `<p>データの取得に失敗しました。</p>`;
  }
}
main();
getEarthquakeInformation();

function callMain() {
    main();
    setTimeout(callMain, 2500);
}

setTimeout(callMain, 2500);
function callEarthquakeInformation() {
    getEarthquakeInformation();
    setTimeout(callEarthquakeInformation, 5000);
}

setTimeout(callEarthquakeInformation, 5000);
      </script>
   </body>
</html>
